<title>JPEGT Converter - Transparent JPEG Files</title>
<style>
:root {
  --primary: #2196F3;
  --dark: #1976D2;
  --light: #BBDEFB;
  --bg: #f5f5f5;
  --surface: white;
  --border: #BBDEFB;
}

[data-theme="dark"] {
  --bg: #121212;
  --surface: #1e1e1e;
  --border: #333;
  --text: #ffffff;
}

body {
  font-family: system-ui, sans-serif;
  margin: 0;
  padding: 20px;
  background: var(--bg);
  color: var(--text);
}

.container {
  max-width: 1200px;
  margin: 0 auto;
}

.drop-zone {
  border: 3px dashed var(--border);
  border-radius: 8px;
  padding: 40px;
  text-align: center;
  background: var(--surface);
  transition: all 0.3s;
}

.drop-zone.drag-over {
  border-color: var(--primary);
  background: var(--light);
}

.quality-slider {
  width: 100%;
  margin: 20px 0;
}

.preview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.preview-item {
  background: var(--surface);
  padding: 10px;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.preview-item img {
  max-width: 100%;
  height: auto;
}

.btn {
  background: var(--primary);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.3s;
}

.btn:hover {
  background: var(--dark);
}

.btn-group {
  display: flex;
  gap: 10px;
  margin: 20px 0;
}

.info {
  background: var(--light);
  padding: 20px;
  border-radius: 8px;
  margin: 20px 0;
}

#dropZone {
  cursor: pointer;
}

.viewer {
  background: var(--surface);
  padding: 20px;
  border-radius: 8px;
  margin-top: 40px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.viewer-dropzone {
  border: 3px dashed var(--border);
  border-radius: 8px;
  padding: 20px;
  text-align: center;
  margin: 20px 0;
  transition: all 0.3s;
}

.viewer-dropzone.drag-over {
  border-color: var(--primary);
  background: var(--light);
}

.viewer-preview {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 20px;
  margin-top: 20px;
}

.viewer-preview canvas {
  max-width: 100%;
  height: auto;
  border-radius: 4px;
}

.format-comparison {
  margin: 20px 0;
}

.format-comparison table {
  width: 100%;
  border-collapse: collapse;
}

.format-comparison th, .format-comparison td {
  padding: 10px;
  border: 1px solid var(--border);
  text-align: center;
}

.comparison {
  margin: 40px 0;
}

.comparison-preview {
  display: flex;
  justify-content: space-between;
}

.comparison-item {
  flex: 1;
  padding: 10px;
  border: 1px solid var(--border);
  border-radius: 8px;
  margin: 0 10px;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
</head>
<body>
<div class="container">
  <div class="theme-toggle">
    <button id="themeToggle" class="btn">
      <span class="light-icon">üåû</span>
      <span class="dark-icon" style="display:none">üåô</span>
    </button>
  </div>
  <h1>JPEGT Converter</h1>
  <p>Convert PNGs to transparent JPEGs (.jpgt, .jpet, .jpegt)</p>

  <div class="format-comparison">
    <h3>Format Comparison</h3>
    <table>
      <thead>
        <tr>
          <th>Feature</th>
          <th>JPEG</th>
          <th>PNG</th>
          <th>JPEGT</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Transparency</td>
          <td>‚ùå</td>
          <td>‚úÖ</td>
          <td>‚úÖ</td>
        </tr>
        <tr>
          <td>Compression</td>
          <td>Lossy (small)</td>
          <td>Lossless (large)</td>
          <td>Hybrid (medium)</td>
        </tr>
        <tr>
          <td>Use Case</td>
          <td>Photos</td>
          <td>Graphics</td>
          <td>Both/Clipart (why did I need that?)</td>
        </tr>
        <tr>
          <td>Proprietary</td>
          <td>‚ùå</td>
          <td>‚ùå</td>
          <td>‚úÖ</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div id="dropZone" class="drop-zone">
    <p>Drop PNG files here or click to select</p>
    <input type="file" id="fileInput" accept=".png" style="display: none" multiple>
  </div>

  <div class="quality-controls">
    <label for="quality">JPEG Quality:</label>
    <input type="range" id="quality" class="quality-slider" min="0" max="100" value="85">
    <span id="qualityValue">85%</span>
  </div>

  <button id="convertBtn" class="btn">Convert to JPEGT</button>

  <div id="preview" class="preview"></div>

  <div class="comparison">
    <h2>JPEG vs JPEGT Comparison</h2>
    <div class="comparison-preview">
      <div class="comparison-item">
        <h4>JPEG Version</h4>
        <canvas id="jpegPreview"></canvas>
      </div>
      <div class="comparison-item">
        <h4>JPEGT Version</h4>
        <canvas id="jpegtPreview"></canvas>
      </div>
    </div>
  </div>

  <div class="viewer">
    <h2>JPEGT Viewer</h2>
    <p>Drop JPEGT files here to view them with transparency</p>
    
    <div id="viewerDropZone" class="viewer-dropzone">
      <p>Drop JPEGT files here or click to select</p>
      <input type="file" id="viewerFileInput" accept=".jpegt,.jpgt,.jpet" style="display: none" multiple>
    </div>

    <div id="viewerPreview" class="viewer-preview"></div>
    <div class="btn-group">
      <button id="savePngBtn" class="btn">Save as PNG</button>
    </div>
  </div>
</div>

<script>
const JPEGT_SIGNATURE = new Uint8Array([0x4A, 0x50, 0x47, 0x54, 0x25, 0x25, 0x31, 0x41, 0x59, 0x26, 0x53, 0x58]);
const PNG_SIGNATURE = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);

class JPEGTConverter {
  constructor() {
    this.quality = 85;
  }

  async convertToJPEGT(pngFile) {
    const pngData = await this.readFileAsArrayBuffer(pngFile);
    const img = await this.loadImage(pngFile);
    
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    
    // Draw white background first
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw image on top
    ctx.drawImage(img, 0, 0);
    const jpegData = await this.canvasToJPEG(canvas);
    
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = img.width;
    maskCanvas.height = img.height;
    const maskCtx = maskCanvas.getContext('2d');
    
    maskCtx.drawImage(img, 0, 0);
    const maskPNG = await this.createTransparencyMaskPNG(maskCtx);
    
    return this.combineJPEGT(jpegData, maskPNG);
  }

  async createTransparencyMaskPNG(ctx) {
    const imageData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height);
    const maskData = ctx.createImageData(ctx.canvas.width, ctx.canvas.height);
    
    for (let i = 0; i < imageData.data.length; i += 4) {
      // Alpha 0 (transparent) -> Black (0)
      // Alpha 255 (opaque) -> White (255) 
      const maskValue = imageData.data[i + 3]; // Use alpha directly, no inversion needed
      maskData.data[i] = maskValue;     // R = Alpha
      maskData.data[i + 1] = maskValue; // G = Alpha
      maskData.data[i + 2] = maskValue; // B = Alpha
      maskData.data[i + 3] = 255;       // A = 255
    }
    
    ctx.putImageData(maskData, 0, 0);
    
    return new Promise((resolve) => {
      ctx.canvas.toBlob((blob) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsArrayBuffer(blob);
      }, 'image/png');
    });
  }

  combineJPEGT(jpegData, maskPNGData) {
    // Compress the PNG mask data using pako
    const compressedMask = pako.deflate(new Uint8Array(maskPNGData));
    
    // Add a marker to indicate compressed data
    const marker = new Uint8Array([0x43, 0x4D, 0x50, 0x52]); // "CMPR"
    
    const combined = new Uint8Array(
      JPEGT_SIGNATURE.length + 
      jpegData.byteLength + 
      marker.length +
      compressedMask.byteLength
    );
    
    combined.set(JPEGT_SIGNATURE, 0);
    combined.set(new Uint8Array(jpegData), JPEGT_SIGNATURE.length);
    combined.set(marker, JPEGT_SIGNATURE.length + jpegData.byteLength);
    combined.set(compressedMask, JPEGT_SIGNATURE.length + jpegData.byteLength + marker.length);
    
    return combined;
  }

  async readFileAsArrayBuffer(file) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.readAsArrayBuffer(file);
    });
  }

  async loadImage(file) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.src = URL.createObjectURL(file);
    });
  }

  async canvasToJPEG(canvas) {
    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsArrayBuffer(blob);
      }, 'image/jpeg', this.quality / 100);
    });
  }
}

class JPEGTDisplay {
  static async load(url) {
    const response = await fetch(url);
    const data = new Uint8Array(await response.arrayBuffer());
    
    const signatureLength = JPEGT_SIGNATURE.length;
    
    let jpegEnd = -1;
    for (let i = signatureLength; i < data.length - 1; i++) {
      if (data[i] === 0xFF && data[i + 1] === 0xD9) {
        jpegEnd = i + 2;
        break;
      }
    }
    
    const jpegData = data.slice(signatureLength, jpegEnd);
    
    // Check for compression marker
    const markerStart = jpegEnd;
    const markerEnd = markerStart + 4;
    const marker = data.slice(markerStart, markerEnd);
    const isCompressed = marker[0] === 0x43 && marker[1] === 0x4D && 
                        marker[2] === 0x50 && marker[3] === 0x52;
    
    let maskPNGData;
    if (isCompressed) {
      const compressedData = data.slice(markerEnd);
      maskPNGData = pako.inflate(compressedData);
    } else {
      maskPNGData = data.slice(jpegEnd);
    }
    
    const [img, maskImg] = await Promise.all([
      createImageBitmap(new Blob([jpegData], {type: 'image/jpeg'})),
      createImageBitmap(new Blob([maskPNGData], {type: 'image/png'}))
    ]);
    
    const canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(img, 0, 0);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = img.width;
    maskCanvas.height = img.height;
    const maskCtx = maskCanvas.getContext('2d');
    maskCtx.drawImage(maskImg, 0, 0);
    const maskData = maskCtx.getImageData(0, 0, canvas.width, canvas.height);
    
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i + 3] = maskData.data[i]; // Use red channel from mask as alpha
    }
    
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }
}

async function saveAsPng() {
  const canvases = viewerPreview.querySelectorAll('canvas');
  
  for (const canvas of canvases) {
    // Create blob from canvas
    const blob = await new Promise(resolve => {
      canvas.toBlob(resolve, 'image/png');
    });
    
    // Get original filename from preview item header
    const previewItem = canvas.closest('.preview-item');
    const filename = previewItem.querySelector('h4').textContent;
    const pngFilename = filename.replace(/\.(jpegt|jpgt|jpet)$/i, '.png');
    
    // Create download link
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = pngFilename;
    a.click();
    URL.revokeObjectURL(a.href);
  }
}

// Event listeners
const converter = new JPEGTConverter();
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const qualitySlider = document.getElementById('quality');
const qualityValue = document.getElementById('qualityValue');
const convertBtn = document.getElementById('convertBtn');
const preview = document.getElementById('preview');

const viewerDropZone = document.getElementById('viewerDropZone');
const viewerFileInput = document.getElementById('viewerFileInput');
const viewerPreview = document.getElementById('viewerPreview');

const themeToggle = document.getElementById('themeToggle');

dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  dropZone.classList.add('drag-over');
});
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
dropZone.addEventListener('drop', handleDrop);
fileInput.addEventListener('change', handleFileSelect);
qualitySlider.addEventListener('input', updateQuality);
convertBtn.addEventListener('click', convertFiles);

viewerDropZone.addEventListener('click', () => viewerFileInput.click());
viewerDropZone.addEventListener('dragover', (e) => {
  e.preventDefault();
  viewerDropZone.classList.add('drag-over');
});
viewerDropZone.addEventListener('dragleave', () => viewerDropZone.classList.remove('drag-over'));
viewerDropZone.addEventListener('drop', handleViewerDrop);
viewerFileInput.addEventListener('change', handleViewerFileSelect);
document.getElementById('savePngBtn').addEventListener('click', saveAsPng);

themeToggle.addEventListener('click', () => {
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
  document.documentElement.setAttribute('data-theme', isDark ? 'light' : 'dark');
  themeToggle.querySelector('.light-icon').style.display = isDark ? 'inline' : 'none';
  themeToggle.querySelector('.dark-icon').style.display = isDark ? 'none' : 'inline';
});

function handleDrop(e) {
  e.preventDefault();
  dropZone.classList.remove('drag-over');
  handleFiles(Array.from(e.dataTransfer.files));
}

function handleFileSelect(e) {
  handleFiles(Array.from(e.target.files));
}

async function handleFiles(files) {
  files = files.filter(file => file.type === 'image/png');
  if (files.length === 0) {
    alert('Please select PNG files only');
    return;
  }
  
  preview.innerHTML = '';
  files.forEach(file => {
    const reader = new FileReader();
    reader.onload = async (e) => {
      const div = document.createElement('div');
      div.className = 'preview-item';
      div.innerHTML = `
        <h4>${file.name}</h4>
        <img src="${e.target.result}" alt="Preview of ${file.name}">
      `;
      preview.appendChild(div);
    };
    reader.readAsDataURL(file);
  });

  if (files.length > 0) {
    const firstFile = files[0];
    const img = await converter.loadImage(firstFile);

    // Create JPEG preview using the current quality setting
    const jpegCanvas = document.createElement('canvas');
    jpegCanvas.width = img.width;
    jpegCanvas.height = img.height;
    const ctx = jpegCanvas.getContext('2d');
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, jpegCanvas.width, jpegCanvas.height);
    ctx.drawImage(img, 0, 0);

    // Use current quality setting for JPEG preview
    const jpegPreviewCanvas = document.createElement('canvas');
    jpegPreviewCanvas.width = img.width;
    jpegPreviewCanvas.height = img.height;
    const jpegCtx = jpegPreviewCanvas.getContext('2d');
    
    // Create low quality JPEG blob
    const blob = await new Promise(resolve => {
      jpegCanvas.toBlob(resolve, 'image/jpeg', converter.quality / 100);
    });
    
    // Load low quality JPEG back to canvas
    const jpegImg = await createImageBitmap(blob);
    jpegCtx.drawImage(jpegImg, 0, 0);
    
    document.getElementById('jpegPreview').replaceWith(jpegPreviewCanvas);
    jpegPreviewCanvas.id = 'jpegPreview';
    
    // Create JPEGT preview
    const jpegt = await converter.convertToJPEGT(firstFile);
    const url = URL.createObjectURL(new Blob([jpegt]));
    const jpegtCanvas = await JPEGTDisplay.load(url);
    document.getElementById('jpegtPreview').replaceWith(jpegtCanvas);
    jpegtCanvas.id = 'jpegtPreview';
    URL.revokeObjectURL(url);
  }
}

function updateQuality(e) {
  converter.quality = e.target.value;
  qualityValue.textContent = `${e.target.value}%`;
  
  // Update comparison previews with new quality
  if (fileInput.files.length > 0) {
    handleFiles(Array.from(fileInput.files));
  }
}

async function convertFiles() {
  const files = Array.from(fileInput.files);
  if (files.length === 0) {
    alert('Please select files to convert');
    return;
  }

  for (const file of files) {
    try {
      const jpegt = await converter.convertToJPEGT(file);
      const blob = new Blob([jpegt], { type: 'image/jpegt' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = file.name.replace('.png', '.jpegt');
      a.click();
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Conversion error:', error);
      alert(`Error converting ${file.name}`);
    }
  }
}

function handleViewerDrop(e) {
  e.preventDefault();
  viewerDropZone.classList.remove('drag-over');
  handleViewerFiles(Array.from(e.dataTransfer.files));
}

function handleViewerFileSelect(e) {
  handleViewerFiles(Array.from(e.target.files));
}

async function handleViewerFiles(files) {
  viewerPreview.innerHTML = '';
  
  for (const file of files) {
    if (!file.name.match(/\.(jpegt|jpgt|jpet)$/i)) {
      continue;
    }

    try {
      const url = URL.createObjectURL(file);
      const canvas = await JPEGTDisplay.load(url);
      
      const div = document.createElement('div');
      div.className = 'preview-item';
      div.innerHTML = `<h4>${file.name}</h4>`;
      div.appendChild(canvas);
      
      viewerPreview.appendChild(div);
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Error loading JPEGT:', error);
      alert(`Error loading ${file.name}`);
    }
  }
}

// When dropping on the page, check if it's a JPEGT file
document.addEventListener('dragover', (e) => {
  e.preventDefault();
});

document.addEventListener('drop', (e) => {
  e.preventDefault();
  const files = Array.from(e.dataTransfer.files);
  const jpegts = files.filter(f => f.name.match(/\.(jpegt|jpgt|jpet)$/i));
  
  if (jpegts.length > 0) {
    handleViewerFiles(jpegts);
  } else if (files.some(f => f.type === 'image/png')) {
    handleFiles(files);
  }
});
</script>
</body></html>