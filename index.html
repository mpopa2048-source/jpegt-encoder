<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>JPEGT & JPEGT+ Converter</title>
<style>
:root {
  --primary: #673AB7;
  --dark: #512DA8;
  --bg: #f4f7f6;
  --surface: #ffffff;
  --text: #2c3e50;
  --border: #dcdde1;
}
[data-theme="dark"] {
  --bg: #1a1a1a;
  --surface: #2d3436;
  --text: #dfe6e9;
  --border: #636e72;
}
body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); margin: 0; padding: 20px; }
.container { max-width: 800px; margin: 0 auto; }
.card { background: var(--surface); padding: 30px; border-radius: 16px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); margin-bottom: 25px; }
h1 { margin-top: 0; font-weight: 800; text-align: center; color: var(--primary); }

.drop-zone { border: 3px dashed var(--border); border-radius: 12px; padding: 40px; text-align: center; cursor: pointer; transition: 0.3s; background: rgba(0,0,0,0.01); }
.drop-zone:hover { border-color: var(--primary); background: rgba(103, 58, 183, 0.05); }

.controls { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 25px 0; }
.btn { background: var(--primary); color: white; border: none; padding: 16px; border-radius: 10px; cursor: pointer; font-weight: bold; width: 100%; font-size: 16px; transition: 0.2s; }
.btn:hover { background: var(--dark); transform: translateY(-1px); }

.preview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; margin-top: 20px; }
.preview-item { background: var(--surface); border: 1px solid var(--border); padding: 12px; border-radius: 10px; text-align: center; }
canvas { width: 100%; height: auto; border-radius: 6px; background-image: conic-gradient(#eee 90deg, #fff 90deg 180deg, #eee 180deg 270deg, #fff 270deg); background-size: 16px 16px; border: 1px solid #eee; }

.tag { font-size: 11px; font-weight: 700; padding: 3px 8px; border-radius: 5px; text-transform: uppercase; display: inline-block; margin-bottom: 8px; }
.tag-plus { background: #e67e22; color: #fff; }
.tag-std { background: #3498db; color: #fff; }

select, input[type="range"] { padding: 10px; border-radius: 6px; border: 1px solid var(--border); margin-top: 5px; }
label { font-size: 13px; font-weight: bold; color: var(--primary); }
</style>
</head>
<body>

<div class="container">
  <h1>JPEGT Converter</h1>
  
  <div class="card">
    <div id="dropZone" class="drop-zone">
      <p>Click or Drop <b>PNGs</b> here</p>
      <input type="file" id="fileInput" accept="image/png" style="display: none" multiple>
    </div>

    <div class="controls">
      <div>
        <label>Format Mode</label><br>
        <select id="modeSelect" style="width:100%">
          <option value="plus">JPEGT+ (Smaller Files, JPEG Mask)</option>
          <option value="standard">JPEGT (Larger Files, PNG Mask)</option>
        </select>
      </div>
      <div>
        <label>Quality: <span id="qVal">85%</span></label><br>
        <input type="range" id="quality" min="1" max="100" value="85" style="width:100%">
      </div>
    </div>
    <button id="convertBtn" class="btn">Convert & Download</button>
  </div>

  <div class="card">
    <h3 style="margin-top:0">Viewer / Decoder</h3>
    <div id="viewZone" class="drop-zone" style="padding: 20px;">
      <p>Drop <b>.jpegt, .jpgt or .jpet</b> files here</p>
    </div>
    <div id="viewerPreview" class="preview-grid"></div>
  </div>
</div>

<script>
/**
 * JPEGT Signature logic
 * Standard: JPGT%% + 31 41 59 26 53 58 (Pi BCD)
 * Plus:     JPGT%% + 58 53 26 59 41 31 (Pi BCD Reversed)
 */
const SIG_BASE = [0x4A, 0x50, 0x47, 0x54, 0x25, 0x25]; 
const PI_FWD   = [0x31, 0x41, 0x59, 0x26, 0x53, 0x58];
const PI_REV   = [0x58, 0x53, 0x26, 0x59, 0x41, 0x31];

const SIG_STANDARD = new Uint8Array([...SIG_BASE, ...PI_FWD]);
const SIG_PLUS     = new Uint8Array([...SIG_BASE, ...PI_REV]);

class JPEGT {
  // Fixed: file must be converted to URL before loading into Image
  static async encode(file, quality, isPlus) {
    const url = URL.createObjectURL(file);
    try {
      const img = await this.loadImage(url);
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;

      // 1. Process Main Image (JPEG on White background)
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      const mainBuf = await this.canvasToBuf(canvas, 'image/jpeg', quality);

      // 2. Process Alpha Mask
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      const idata = ctx.getImageData(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < idata.data.length; i += 4) {
        const alpha = idata.data[i + 3];
        idata.data[i] = idata.data[i+1] = idata.data[i+2] = alpha;
        idata.data[i+3] = 255; // Opaque mask
      }
      ctx.putImageData(idata, 0, 0);
      
      const maskBuf = isPlus 
        ? await this.canvasToBuf(canvas, 'image/jpeg', quality) 
        : await this.canvasToBuf(canvas, 'image/png');

      // 3. Assemble final binary
      const sig = isPlus ? SIG_PLUS : SIG_STANDARD;
      const out = new Uint8Array(sig.length + mainBuf.byteLength + maskBuf.byteLength);
      out.set(sig, 0);
      out.set(new Uint8Array(mainBuf), sig.length);
      out.set(new Uint8Array(maskBuf), sig.length + mainBuf.byteLength);
      
      return out;
    } finally {
      URL.revokeObjectURL(url);
    }
  }

  static async decode(arrayBuffer) {
    const data = new Uint8Array(arrayBuffer);
    
    // Validate Signature
    const sigStr = String.fromCharCode(...data.slice(0, 4));
    if (sigStr !== "JPGT") throw new Error("Invalid JPEGT Signature");

    const isPlus = data[6] === 0x58; // 0x58 is the start of reversed Pi

    // Splitter: Skip signature (12 bytes) and find next file header
    let maskOffset = -1;
    for (let i = 20; i < data.length - 4; i++) {
      // JPEG Start: FF D8 FF
      if (data[i] === 0xFF && data[i+1] === 0xD8 && data[i+2] === 0xFF) {
        maskOffset = i;
        break;
      }
      // PNG Start: 89 50 4E 47
      if (data[i] === 0x89 && data[i+1] === 0x50 && data[i+2] === 0x4E && data[i+3] === 0x47) {
        maskOffset = i;
        break;
      }
    }

    if (maskOffset === -1) throw new Error("Could not split JPEGT components");

    const img1Url = URL.createObjectURL(new Blob([data.slice(12, maskOffset)], {type: 'image/jpeg'}));
    const img2Url = URL.createObjectURL(new Blob([data.slice(maskOffset)], {type: isPlus ? 'image/jpeg' : 'image/png'}));

    try {
      const [img, mask] = await Promise.all([
        this.loadImage(img1Url),
        this.loadImage(img2Url)
      ]);

      const canvas = document.createElement('canvas');
      canvas.width = img.width; canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      
      const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const mCanvas = document.createElement('canvas');
      mCanvas.width = img.width; mCanvas.height = img.height;
      const mCtx = mCanvas.getContext('2d');
      mCtx.drawImage(mask, 0, 0);
      const mPixels = mCtx.getImageData(0, 0, canvas.width, canvas.height);

      for (let i = 0; i < pixels.data.length; i += 4) {
        pixels.data[i+3] = mPixels.data[i]; // Apply mask Red channel to Alpha channel
      }

      ctx.putImageData(pixels, 0, 0);
      return { canvas, type: isPlus ? 'JPEGT+' : 'JPEGT' };
    } finally {
      URL.revokeObjectURL(img1Url);
      URL.revokeObjectURL(img2Url);
    }
  }

  static loadImage(url) {
    return new Promise((res, rej) => {
      const img = new Image();
      img.onload = () => res(img);
      img.onerror = (err) => rej(new Error("Image Load Failed: check if input is a valid image."));
      img.src = url;
    });
  }

  static canvasToBuf(canvas, type, q) {
    return new Promise(res => canvas.toBlob(b => {
      const r = new FileReader();
      r.onload = () => res(r.result);
      r.readAsArrayBuffer(b);
    }, type, q));
  }
}

// --- UI Interaction ---
const $ = id => document.getElementById(id);

$('dropZone').onclick = () => $('fileInput').click();
$('quality').oninput = () => $('qVal').innerText = $('quality').value + '%';

$('convertBtn').onclick = async () => {
  const files = $('fileInput').files;
  if (!files.length) return alert("Please select PNG files first.");
  const isPlus = $('modeSelect').value === 'plus';

  for (const f of files) {
    try {
      const data = await JPEGT.encode(f, $('quality').value / 100, isPlus);
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([data]));
      a.download = f.name.replace('.png', isPlus ? '.jpegt' : '.jpegt');
      a.click();
      URL.revokeObjectURL(a.href);
    } catch (e) {
      alert(`Error converting ${f.name}: ${e.message}`);
    }
  }
};

const handleView = async (files) => {
  for (const f of files) {
    try {
      const buf = await f.arrayBuffer();
      const {canvas, type} = await JPEGT.decode(buf);
      const div = document.createElement('div');
      div.className = 'preview-item';
      div.innerHTML = `<span class="tag ${type === 'JPEGT+' ? 'tag-plus' : 'tag-std'}">${type}</span>`;
      div.appendChild(canvas);
      $('viewerPreview').prepend(div);
    } catch (e) {
      alert(`Error decoding ${f.name}: ${e.message}`);
    }
  }
};

$('viewZone').onclick = () => {
  const i = document.createElement('input');
  i.type = 'file'; i.multiple = true;
  i.onchange = (e) => handleView(e.target.files);
  i.click();
};

window.ondragover = e => e.preventDefault();
window.ondrop = e => {
  e.preventDefault();
  const files = e.dataTransfer.files;
  if (!files.length) return;
  
  if (files[0].name.endsWith('.png')) {
    $('fileInput').files = files;
    $('qVal').innerText = "Loaded " + files.length + " files";
  } else {
    handleView(files);
  }
};
</script>
</body>
</html>